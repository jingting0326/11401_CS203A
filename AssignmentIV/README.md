# Assignment IV: Hash Function Design & Observation

**姓名：** [廖婧婷]
**學號：** [1111426]

## 1. 開發歷史

* **2025/11/12 22:20:** 建立專案結構並加入範本檔案
* **2025/11/12 22:50:** 完成 hash_fn.c中的整數
* **2025/11/13 18:30:** 完成README中hash_fn.c中的整數
* **2025/11/13 19:30:** 完成hash_fn.c中的整數並填寫觀察結果
---

## 2. Hash Function 設計理念
### A. 整數 Hash
 
    * **公式:** `index = key % m`
    * **理由:** 實作簡單且對於 m 是質數時，分佈效果不錯
    * **負數處理:** 確保即使 key 是負數，回傳的 index 也絕對會在 0 到 m-1 的範圍內。
    * **負數處理公式:** index = (index + m) % m 例如(-5 + 10) % 10 = 5 % 10 = 5
### B.字串 Hash
    * **方法:** Summation Method+Division Method
    * **轉換:** 遍歷每個字元，將ASCII全部加總，得到long type 的hash。得到之後，再用整數Hash的方法，使用 Division Method。
    * **負數處理:** 確保即使 key 是負數，回傳的 index 也絕對會在 0 到 m-1 的範圍內。
    * ** 負數處理公式:** index = (index + m) % m 例如(-5 + 10) % 10 = 5 % 10 = 5
## 3. 測試結果與觀察(C和C++相同)
### A. 整數 Hash

執行結果(m=10)

```text
=== Table Size m = 10 ===
Key     Index
-----------------
21      1
51      1
52      2
53      3
54      4
55      5 
22      2
23      3
24      4
25      5
26      6
27      7
28      8
29      9
30      0
56      6
57      7
58      8
59      9
60      0
```
### 觀察
**分布:** 最差
**碰撞:** 十次(每組2個)
**原因:**m=10，每次對策資取餘數時，剛好都看到個位數。

執行結果(m=11)

```text

=== Table Size m = 11 ===
Key     Index
-----------------
21      10
22      0
23      1
24      2
25      3
26      4
27      5
28      6
29      7
30      8
51      7
52      8
53      9
54      10
55      0
56      1
57      2
58      3
59      4
60      5
```
### 觀察
**分布:** 較好
**碰撞:** 八次
**原因:**m=11，11是質數，打亂剛才m=10時的規律

執行結果(m=37)

```text

=== Table Size m = 37 ===
Key     Index
-----------------
21      21
22      22
23      23
24      24
25      25
26      26
27      27
28      28
29      29
30      30
51      14
52      15
53      16
54      17
55      18
56      19
57      20
58      21
59      22
60      23
```
### 觀察
**分布:** 最好
**碰撞:** 3次
**原因:**m=37，37也是質數，比測試資料量還大

### B.字串 Hash
執行結果(m=10)
```text
Key     Index
-----------------
cat     2
dog     4
bat     1
cow     9
ant     3
owl     8
bee     0
hen     5
pig     0
fox     3

```
### 觀察
**分布:** 普通
**碰撞:** 2次
**原因:** 用10取餘數，一樣只會看到個位數

執行結果(m=11)
```text
=== String Hash (m = 11) ===
Key     Index
-----------------
cat     4
dog     6
bat     3
cow     10
ant     4
owl     8
bee     3
hen     7
pig     1
fox     3
```
### 觀察
**分布:** 最差
**碰撞:** 一樣是2次，但3對應到了兩個測資
**原因:**設計太簡單，沒辦法分辨 bat bee這兩種組合

執行結果(m=37)
```text
=== String Hash (m = 37) ===
Key     Index
-----------------
cat     16
dog     18
bat     15
cow     33
ant     27
owl     5
bee     4
hen     19
pig     24
fox     0
```
### 觀察
**分布:** 最好
**碰撞:** 0次
**原因:** 同時有質數和筆資料量大兩個數值，但m=11證明質數對分布不一定是好的。由此可知因為m>>資料量(10)，碰撞機率可以大幅降低

## 4. 總結分析 
### A. 整數 Hash
    **碰撞:** m=10>m=11>m=37
    **思考:** 表格大小為10或100這種數時，因為取餘數只會取道後面個位數的部分，所以最容易發生碰撞(除非今天資料中的個位數都不同)。而表格大小為11時，因為是質數，可以改善合數時發生的碰撞。最後是表格大小為37時， 因為37大於資料數的20又同時為質數，所以可以將碰撞降低到最少。
    **結論:** 表格大小大於資料數很重要，質數也能有效改善合數的碰撞情形。
### B.字串 Hash
    **碰撞:** m=11>m=10>m=37
    **思考:** 和整數Hash大致相同，但在字串的部分，質數或合數並沒有太大的影響，因為設計過於簡單，連質數也無法改善碰撞問題。最後還是要靠著大幅提高表格的大小來減少碰撞機率。
    **結論:** 表格大小大於資料數很重要!

